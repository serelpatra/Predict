<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù¾ÛŒØ´Ø¨ÛŒÙ†ÛŒ Ù†ØªÛŒØ¬Ù‡ ÙÙˆØªØ¨Ø§Ù„ - Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700&display=swap');
        * {
            font-family: 'Vazirmatn', sans-serif;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .card-shadow {
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .prediction-result {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        .ml-badge {
            background: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <div class="gradient-bg text-white py-8">
        <div class="container mx-auto px-4 text-center">
            <h1 class="text-4xl font-bold mb-2">ğŸ¤– Ù¾ÛŒØ´Ø¨ÛŒÙ†ÛŒ ÙÙˆØªØ¨Ø§Ù„ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h1>
            <p class="text-lg opacity-90">Ø³ÛŒØ³ØªÙ… Ù¾ÛŒØ´Ø±ÙØªÙ‡ Machine Learning + Neural Network</p>
            <div class="ml-badge text-white px-4 py-2 rounded-full inline-block mt-2 text-sm font-bold">
                ğŸ§  AI-Powered Prediction Engine
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <!-- Navigation Tabs -->
        <div class="flex flex-wrap justify-center mb-8 bg-white rounded-lg p-2 card-shadow">
            <button onclick="showTab('teams')" id="teams-tab" class="tab-btn px-6 py-3 rounded-lg font-medium transition-all bg-blue-500 text-white">
                ğŸ“Š Ù…Ø¯ÛŒØ±ÛŒØª ØªÛŒÙ…â€ŒÙ‡Ø§
            </button>
            <button onclick="showTab('matches')" id="matches-tab" class="tab-btn px-6 py-3 rounded-lg font-medium transition-all text-gray-600 hover:bg-gray-100">
                ğŸ“‹ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§
            </button>
            <button onclick="showTab('predict')" id="predict-tab" class="tab-btn px-6 py-3 rounded-lg font-medium transition-all text-gray-600 hover:bg-gray-100">
                ğŸ¤– Ù¾ÛŒØ´Ø¨ÛŒÙ†ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯
            </button>
        </div>

        <!-- Data Management Bar -->
        <div class="bg-white rounded-lg p-4 mb-6 card-shadow">
            <div class="flex flex-wrap justify-center gap-3">
                <button onclick="saveData()" class="bg-green-500 text-white px-4 py-2 rounded-lg font-medium hover:bg-green-600 transition-colors">
                    ğŸ’¾ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                </button>
                <button onclick="exportData()" class="bg-blue-500 text-white px-4 py-2 rounded-lg font-medium hover:bg-blue-600 transition-colors">
                    ğŸ“¤ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù¾Ø´ØªÛŒØ¨Ø§Ù†
                </button>
                <label class="bg-purple-500 text-white px-4 py-2 rounded-lg font-medium hover:bg-purple-600 transition-colors cursor-pointer">
                    ğŸ“¥ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†
                    <input type="file" accept=".json" onchange="importData(event)" class="hidden">
                </label>
                <button onclick="clearAllData()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-medium hover:bg-red-600 transition-colors">
                    ğŸ—‘ï¸ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù‡Ù…Ù‡
                </button>
                <button onclick="trainModel()" class="bg-gradient-to-r from-orange-500 to-red-500 text-white px-4 py-2 rounded-lg font-medium hover:from-orange-600 hover:to-red-600 transition-colors">
                    ğŸ§  Ø¢Ù…ÙˆØ²Ø´ Ù…Ø¯Ù„ AI
                </button>
            </div>
        </div>

        <!-- Teams Management Tab -->
        <div id="teams-content" class="tab-content">
            <div class="grid lg:grid-cols-2 gap-8">
                <!-- Add Team -->
                <div class="bg-white rounded-xl p-6 card-shadow">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">â• Ø§ÙØ²ÙˆØ¯Ù† ØªÛŒÙ… Ø¬Ø¯ÛŒØ¯</h3>
                    <div class="space-y-4">
                        <input type="text" id="team-name" placeholder="Ù†Ø§Ù… ØªÛŒÙ…" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <div class="grid grid-cols-3 gap-3">
                            <input type="number" id="team-wins" placeholder="Ø¨Ø±Ø¯" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <input type="number" id="team-draws" placeholder="Ù…Ø³Ø§ÙˆÛŒ" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-yellow-500">
                            <input type="number" id="team-losses" placeholder="Ø¨Ø§Ø®Øª" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500">
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <input type="number" id="team-goals-for" placeholder="Ú¯Ù„ Ø²Ø¯Ù‡" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            <input type="number" id="team-goals-against" placeholder="Ú¯Ù„ Ø®ÙˆØ±Ø¯Ù‡" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        </div>
                        <button onclick="addTeam()" class="w-full bg-blue-500 text-white py-3 rounded-lg font-medium hover:bg-blue-600 transition-colors">
                            Ø§ÙØ²ÙˆØ¯Ù† ØªÛŒÙ…
                        </button>
                    </div>
                </div>

                <!-- Teams List -->
                <div class="bg-white rounded-xl p-6 card-shadow">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">ğŸ“‹ Ø¬Ø¯ÙˆÙ„ Ù„ÛŒÚ¯</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="p-3 text-right">ØªÛŒÙ…</th>
                                    <th class="p-3 text-center">Ø§Ù…ØªÛŒØ§Ø²</th>
                                    <th class="p-3 text-center">ELO</th>
                                    <th class="p-3 text-center">AI Score</th>
                                    <th class="p-3 text-center">Ø¹Ù…Ù„ÛŒØ§Øª</th>
                                </tr>
                            </thead>
                            <tbody id="teams-table">
                                <!-- Teams will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Matches History Tab -->
        <div id="matches-content" class="tab-content hidden">
            <div class="grid lg:grid-cols-2 gap-8">
                <!-- Add Match -->
                <div class="bg-white rounded-xl p-6 card-shadow">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">â• Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ø§Ø²ÛŒ</h3>
                    <div class="space-y-4">
                        <select id="home-team" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            <option value="">ØªÛŒÙ… Ù…ÛŒØ²Ø¨Ø§Ù†</option>
                        </select>
                        <select id="away-team" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            <option value="">ØªÛŒÙ… Ù…ÛŒÙ‡Ù…Ø§Ù†</option>
                        </select>
                        <div class="grid grid-cols-2 gap-3">
                            <input type="number" id="home-goals" placeholder="Ú¯Ù„ Ù…ÛŒØ²Ø¨Ø§Ù†" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            <input type="number" id="away-goals" placeholder="Ú¯Ù„ Ù…ÛŒÙ‡Ù…Ø§Ù†" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        </div>
                        <input type="date" id="match-date" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        <button onclick="addMatch()" class="w-full bg-green-500 text-white py-3 rounded-lg font-medium hover:bg-green-600 transition-colors">
                            Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ø§Ø²ÛŒ
                        </button>
                    </div>
                </div>

                <!-- Matches List -->
                <div class="bg-white rounded-xl p-6 card-shadow">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">ğŸ“… ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§</h3>
                    <div class="space-y-3 max-h-96 overflow-y-auto" id="matches-list">
                        <!-- Matches will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Prediction Tab -->
        <div id="predict-content" class="tab-content hidden">
            <div class="max-w-4xl mx-auto">
                <div class="bg-white rounded-xl p-8 card-shadow">
                    <h3 class="text-2xl font-bold mb-6 text-center text-gray-800">ğŸ¤– Ù¾ÛŒØ´Ø¨ÛŒÙ†ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¨Ø§ AI</h3>
                    
                    <div class="grid md:grid-cols-2 gap-6 mb-8">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">ØªÛŒÙ… Ù…ÛŒØ²Ø¨Ø§Ù†</label>
                            <select id="predict-home" class="w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 text-lg">
                                <option value="">Ø§Ù†ØªØ®Ø§Ø¨ ØªÛŒÙ… Ù…ÛŒØ²Ø¨Ø§Ù†</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">ØªÛŒÙ… Ù…ÛŒÙ‡Ù…Ø§Ù†</label>
                            <select id="predict-away" class="w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 text-lg">
                                <option value="">Ø§Ù†ØªØ®Ø§Ø¨ ØªÛŒÙ… Ù…ÛŒÙ‡Ù…Ø§Ù†</option>
                            </select>
                        </div>
                    </div>

                    <button onclick="predictMatch()" class="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-4 rounded-lg font-bold text-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105">
                        ğŸ§  Ù¾ÛŒØ´Ø¨ÛŒÙ†ÛŒ Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ
                    </button>

                    <div id="prediction-result" class="hidden mt-8 p-6 rounded-xl text-white text-center prediction-result">
                        <!-- Prediction result will be shown here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let teams = [];
        let matches = [];
        let mlModel = null;
        let modelTrained = false;

        // Machine Learning Model Class
        class FootballMLModel {
            constructor() {
                this.weights = {
                    // Feature weights for neural network
                    eloRating: 0.25,
                    winRate: 0.20,
                    goalDifference: 0.15,
                    recentForm: 0.15,
                    homeAdvantage: 0.10,
                    headToHead: 0.10,
                    attackStrength: 0.05
                };
                this.bias = 0.5;
                this.learningRate = 0.01;
                this.trained = false;
            }

            // Extract features from team data
            extractFeatures(homeTeam, awayTeam) {
                const homeFeatures = this.getTeamFeatures(homeTeam, true);
                const awayFeatures = this.getTeamFeatures(awayTeam, false);
                
                // Calculate relative features
                const features = {
                    eloRatingDiff: (homeFeatures.eloRating - awayFeatures.eloRating) / 400,
                    winRateDiff: homeFeatures.winRate - awayFeatures.winRate,
                    goalDiffRatio: homeFeatures.goalDifference - awayFeatures.goalDifference,
                    formDiff: homeFeatures.recentForm - awayFeatures.recentForm,
                    homeAdvantage: 0.15, // Static home advantage
                    headToHead: this.getH2HFeature(homeTeam.id, awayTeam.id),
                    attackDefenseRatio: (homeFeatures.attackStrength / awayFeatures.defenseStrength) - 1
                };

                return features;
            }

            getTeamFeatures(team, isHome) {
                const totalGames = team.wins + team.draws + team.losses;
                
                return {
                    eloRating: team.eloRating || 1500,
                    winRate: totalGames > 0 ? team.wins / totalGames : 0,
                    goalDifference: team.goalsFor - team.goalsAgainst,
                    recentForm: this.getRecentForm(team, 5),
                    attackStrength: totalGames > 0 ? team.goalsFor / totalGames : 1,
                    defenseStrength: totalGames > 0 ? team.goalsAgainst / totalGames : 1
                };
            }

            getRecentForm(team, numGames) {
                const recentMatches = matches.filter(m => 
                    m.homeTeam === team.id || m.awayTeam === team.id
                ).slice(-numGames);

                if (recentMatches.length === 0) return 0.5;

                let points = 0;
                recentMatches.forEach(match => {
                    if (match.homeTeam === team.id) {
                        if (match.homeGoals > match.awayGoals) points += 3;
                        else if (match.homeGoals === match.awayGoals) points += 1;
                    } else {
                        if (match.awayGoals > match.homeGoals) points += 3;
                        else if (match.awayGoals === match.homeGoals) points += 1;
                    }
                });

                return points / (recentMatches.length * 3);
            }

            getH2HFeature(team1Id, team2Id) {
                const h2hMatches = matches.filter(m => 
                    (m.homeTeam === team1Id && m.awayTeam === team2Id) ||
                    (m.homeTeam === team2Id && m.awayTeam === team1Id)
                );

                if (h2hMatches.length === 0) return 0;

                let team1Wins = 0;
                h2hMatches.forEach(match => {
                    if ((match.homeTeam === team1Id && match.homeGoals > match.awayGoals) ||
                        (match.awayTeam === team1Id && match.awayGoals > match.homeGoals)) {
                        team1Wins++;
                    }
                });

                return (team1Wins / h2hMatches.length) - 0.5; // Normalize to [-0.5, 0.5]
            }

            // Neural Network Forward Pass
            predict(homeTeam, awayTeam) {
                const features = this.extractFeatures(homeTeam, awayTeam);
                
                // Calculate weighted sum
                let score = this.bias;
                for (const [feature, value] of Object.entries(features)) {
                    if (this.weights[feature]) {
                        score += this.weights[feature] * value;
                    }
                }

                // Apply sigmoid activation
                const homeWinProb = this.sigmoid(score);
                const awayWinProb = this.sigmoid(-score);
                const drawProb = 1 - homeWinProb - awayWinProb;

                // Normalize probabilities
                const total = homeWinProb + drawProb + awayWinProb;
                
                return {
                    homeWinProb: (homeWinProb / total) * 100,
                    drawProb: (drawProb / total) * 100,
                    awayWinProb: (awayWinProb / total) * 100,
                    confidence: this.calculateConfidence(features),
                    features: features
                };
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            calculateConfidence(features) {
                // Confidence based on feature strength
                const featureStrength = Math.abs(features.eloRatingDiff) + 
                                      Math.abs(features.winRateDiff) + 
                                      Math.abs(features.formDiff);
                
                return Math.min(95, Math.max(65, 70 + featureStrength * 25));
            }

            // Training function (simplified backpropagation)
            train() {
                if (matches.length < 10) {
                    showNotification('âŒ Ø­Ø¯Ø§Ù‚Ù„ 10 Ø¨Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ø¢Ù…ÙˆØ²Ø´ Ù…Ø¯Ù„ Ù†ÛŒØ§Ø² Ø§Ø³Øª', 'error');
                    return false;
                }

                const trainingData = this.prepareTrainingData();
                
                // Simple gradient descent
                for (let epoch = 0; epoch < 100; epoch++) {
                    let totalError = 0;
                    
                    trainingData.forEach(sample => {
                        const prediction = this.forwardPass(sample.features);
                        const error = sample.actual - prediction;
                        totalError += Math.abs(error);
                        
                        // Update weights
                        for (const [feature, value] of Object.entries(sample.features)) {
                            if (this.weights[feature]) {
                                this.weights[feature] += this.learningRate * error * value;
                            }
                        }
                        this.bias += this.learningRate * error;
                    });
                    
                    if (totalError < 0.1) break; // Convergence
                }

                this.trained = true;
                showNotification('ğŸ§  Ù…Ø¯Ù„ AI Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù…ÙˆØ²Ø´ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯!', 'success');
                return true;
            }

            prepareTrainingData() {
                const trainingData = [];
                
                matches.forEach(match => {
                    const homeTeam = teams.find(t => t.id === match.homeTeam);
                    const awayTeam = teams.find(t => t.id === match.awayTeam);
                    
                    if (homeTeam && awayTeam) {
                        const features = this.extractFeatures(homeTeam, awayTeam);
                        
                        // Determine actual result
                        let actual;
                        if (match.homeGoals > match.awayGoals) actual = 1; // Home win
                        else if (match.homeGoals < match.awayGoals) actual = 0; // Away win
                        else actual = 0.5; // Draw
                        
                        trainingData.push({ features, actual });
                    }
                });
                
                return trainingData;
            }

            forwardPass(features) {
                let score = this.bias;
                for (const [feature, value] of Object.entries(features)) {
                    if (this.weights[feature]) {
                        score += this.weights[feature] * value;
                    }
                }
                return this.sigmoid(score);
            }
        }

        // Initialize ML Model
        mlModel = new FootballMLModel();

        // Local Storage Functions
        function saveData() {
            try {
                localStorage.setItem('footballPrediction_teams', JSON.stringify(teams));
                localStorage.setItem('footballPrediction_matches', JSON.stringify(matches));
                if (mlModel && mlModel.trained) {
                    localStorage.setItem('footballPrediction_mlModel', JSON.stringify(mlModel.weights));
                }
                showNotification('âœ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯', 'success');
            } catch (error) {
                showNotification('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ', 'error');
            }
        }

        function loadData() {
            try {
                const savedTeams = localStorage.getItem('footballPrediction_teams');
                const savedMatches = localStorage.getItem('footballPrediction_matches');
                const savedModel = localStorage.getItem('footballPrediction_mlModel');
                
                if (savedTeams) {
                    teams = JSON.parse(savedTeams);
                }
                if (savedMatches) {
                    matches = JSON.parse(savedMatches);
                }
                if (savedModel) {
                    mlModel.weights = JSON.parse(savedModel);
                    mlModel.trained = true;
                    modelTrained = true;
                }
                
                if (teams.length > 0 || matches.length > 0) {
                    showNotification('ğŸ“‚ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯', 'success');
                }
            } catch (error) {
                showNotification('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§', 'error');
                teams = [];
                matches = [];
            }
        }

        function exportData() {
            const data = {
                teams: teams,
                matches: matches,
                mlModel: mlModel.trained ? mlModel.weights : null,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `football_ai_backup_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            showNotification('ğŸ’¾ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø´Ø¯', 'success');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.teams && data.matches) {
                        teams = data.teams;
                        matches = data.matches;
                        
                        if (data.mlModel) {
                            mlModel.weights = data.mlModel;
                            mlModel.trained = true;
                            modelTrained = true;
                        }
                        
                        saveData();
                        updateTeamsDisplay();
                        updateMatchesDisplay();
                        updateTeamSelects();
                        showNotification('ğŸ“¥ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ø±Ø¯ Ø´Ø¯', 'success');
                    } else {
                        showNotification('âŒ ÙØ±Ù…Øª ÙØ§ÛŒÙ„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª', 'error');
                    }
                } catch (error) {
                    showNotification('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† ÙØ§ÛŒÙ„', 'error');
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }

        function clearAllData() {
            if (confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù‡Ù…Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ù¾Ø§Ú© Ú©Ù†ÛŒØ¯ØŸ')) {
                teams = [];
                matches = [];
                mlModel = new FootballMLModel();
                modelTrained = false;
                localStorage.removeItem('footballPrediction_teams');
                localStorage.removeItem('footballPrediction_matches');
                localStorage.removeItem('footballPrediction_mlModel');
                updateTeamsDisplay();
                updateMatchesDisplay();
                updateTeamSelects();
                document.getElementById('prediction-result').classList.add('hidden');
                showNotification('ğŸ—‘ï¸ Ù‡Ù…Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù¾Ø§Ú© Ø´Ø¯', 'success');
            }
        }

        function trainModel() {
            if (mlModel.train()) {
                modelTrained = true;
                saveData();
                updateTeamsDisplay(); // Update AI scores
            }
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 z-50 px-6 py-3 rounded-lg text-white font-medium transform transition-all duration-300 ${
                type === 'success' ? 'bg-green-500' : 'bg-red-500'
            }`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Tab Management
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('text-gray-600', 'hover:bg-gray-100');
            });

            // Show selected tab
            document.getElementById(tabName + '-content').classList.remove('hidden');
            document.getElementById(tabName + '-tab').classList.add('bg-blue-500', 'text-white');
            document.getElementById(tabName + '-tab').classList.remove('text-gray-600', 'hover:bg-gray-100');
        }

        // Team Management
        function addTeam() {
            const name = document.getElementById('team-name').value.trim();
            const wins = parseInt(document.getElementById('team-wins').value) || 0;
            const draws = parseInt(document.getElementById('team-draws').value) || 0;
            const losses = parseInt(document.getElementById('team-losses').value) || 0;
            const goalsFor = parseInt(document.getElementById('team-goals-for').value) || 0;
            const goalsAgainst = parseInt(document.getElementById('team-goals-against').value) || 0;

            if (!name) {
                alert('Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… ØªÛŒÙ… Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯');
                return;
            }

            if (teams.find(team => team.name === name)) {
                alert('Ø§ÛŒÙ† ØªÛŒÙ… Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡ Ø§Ø³Øª');
                return;
            }

            const team = {
                id: Date.now(),
                name,
                wins,
                draws,
                losses,
                goalsFor,
                goalsAgainst,
                points: wins * 3 + draws,
                goalDifference: goalsFor - goalsAgainst,
                eloRating: 1500, // Starting ELO rating
                aiScore: 1500, // AI-calculated score
                form: []
            };

            teams.push(team);
            saveData(); // Auto-save when adding team
            updateTeamsDisplay();
            updateTeamSelects();
            clearTeamForm();
        }

        function deleteTeam(id) {
            teams = teams.filter(team => team.id !== id);
            matches = matches.filter(match => match.homeTeam !== id && match.awayTeam !== id);
            saveData(); // Auto-save when deleting team
            updateTeamsDisplay();
            updateTeamSelects();
            updateMatchesDisplay();
        }

        function clearTeamForm() {
            document.getElementById('team-name').value = '';
            document.getElementById('team-wins').value = '';
            document.getElementById('team-draws').value = '';
            document.getElementById('team-losses').value = '';
            document.getElementById('team-goals-for').value = '';
            document.getElementById('team-goals-against').value = '';
        }

        function updateTeamsDisplay() {
            // Update ELO ratings first
            updateELORatings();
            
            // Calculate AI scores if model is trained
            if (modelTrained && teams.length > 1) {
                updateAIScores();
            }
            
            const sortedTeams = [...teams].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.goalDifference - a.goalDifference;
            });

            const tbody = document.getElementById('teams-table');
            tbody.innerHTML = sortedTeams.map((team, index) => `
                <tr class="border-b hover:bg-gray-50">
                    <td class="p-3">
                        <div class="flex items-center">
                            <span class="w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center text-xs mr-2">${index + 1}</span>
                            <span class="font-medium">${team.name}</span>
                        </div>
                    </td>
                    <td class="p-3 text-center font-bold text-blue-600">${team.points}</td>
                    <td class="p-3 text-center font-bold text-purple-600">${Math.round(team.eloRating)}</td>
                    <td class="p-3 text-center font-bold text-orange-600">${Math.round(team.aiScore || 1500)}</td>
                    <td class="p-3 text-center">
                        <button onclick="deleteTeam(${team.id})" class="bg-red-500 text-white px-3 py-1 rounded text-xs hover:bg-red-600">
                            Ø­Ø°Ù
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        function updateAIScores() {
            teams.forEach(team => {
                const features = mlModel.getTeamFeatures(team, false);
                // Calculate AI score based on multiple factors
                team.aiScore = 1500 + 
                    (features.winRate - 0.5) * 400 + 
                    features.goalDifference * 10 + 
                    (features.recentForm - 0.5) * 200 +
                    (team.eloRating - 1500) * 0.3;
            });
        }

        function updateTeamSelects() {
            const selects = ['home-team', 'away-team', 'predict-home', 'predict-away'];
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                const currentValue = select.value;
                select.innerHTML = `<option value="">${selectId.includes('home') ? 'ØªÛŒÙ… Ù…ÛŒØ²Ø¨Ø§Ù†' : 'ØªÛŒÙ… Ù…ÛŒÙ‡Ù…Ø§Ù†'}</option>` +
                    teams.map(team => `<option value="${team.id}">${team.name}</option>`).join('');
                select.value = currentValue;
            });
        }

        // Match Management
        function addMatch() {
            const homeTeamId = parseInt(document.getElementById('home-team').value);
            const awayTeamId = parseInt(document.getElementById('away-team').value);
            const homeGoals = parseInt(document.getElementById('home-goals').value) || 0;
            const awayGoals = parseInt(document.getElementById('away-goals').value) || 0;
            const date = document.getElementById('match-date').value;

            if (!homeTeamId || !awayTeamId) {
                alert('Ù„Ø·ÙØ§Ù‹ Ù‡Ø± Ø¯Ùˆ ØªÛŒÙ… Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯');
                return;
            }

            if (homeTeamId === awayTeamId) {
                alert('ØªÛŒÙ… Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø§ Ø®ÙˆØ¯Ø´ Ø¨Ø§Ø²ÛŒ Ú©Ù†Ø¯');
                return;
            }

            const match = {
                id: Date.now(),
                homeTeam: homeTeamId,
                awayTeam: awayTeamId,
                homeGoals,
                awayGoals,
                date: date || new Date().toISOString().split('T')[0],
                eloProcessed: false
            };

            matches.push(match);
            saveData(); // Auto-save when adding match
            updateMatchesDisplay();
            updateTeamsDisplay(); // Update ELO ratings
            clearMatchForm();
        }

        function clearMatchForm() {
            document.getElementById('home-team').value = '';
            document.getElementById('away-team').value = '';
            document.getElementById('home-goals').value = '';
            document.getElementById('away-goals').value = '';
            document.getElementById('match-date').value = '';
        }

        function updateMatchesDisplay() {
            const matchesList = document.getElementById('matches-list');
            if (matches.length === 0) {
                matchesList.innerHTML = '<p class="text-gray-500 text-center py-4">Ù‡Ù†ÙˆØ² Ø¨Ø§Ø²ÛŒâ€ŒØ§ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª</p>';
                return;
            }

            matchesList.innerHTML = matches.slice(-10).reverse().map(match => {
                const homeTeam = teams.find(t => t.id === match.homeTeam);
                const awayTeam = teams.find(t => t.id === match.awayTeam);
                
                return `
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <div class="flex justify-between items-center">
                            <div class="text-sm text-gray-600">${match.date}</div>
                            <button onclick="deleteMatch(${match.id})" class="text-red-500 hover:text-red-700 text-sm">Ø­Ø°Ù</button>
                        </div>
                        <div class="flex items-center justify-between mt-2">
                            <span class="font-medium">${homeTeam?.name || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</span>
                            <div class="bg-white px-3 py-1 rounded font-bold">
                                ${match.homeGoals} - ${match.awayGoals}
                            </div>
                            <span class="font-medium">${awayTeam?.name || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function deleteMatch(id) {
            matches = matches.filter(match => match.id !== id);
            // Reset ELO processing for remaining matches
            matches.forEach(match => match.eloProcessed = false);
            saveData(); // Auto-save when deleting match
            updateMatchesDisplay();
            updateTeamsDisplay();
        }

        // Machine Learning Prediction
        function predictMatch() {
            const homeTeamId = parseInt(document.getElementById('predict-home').value);
            const awayTeamId = parseInt(document.getElementById('predict-away').value);

            if (!homeTeamId || !awayTeamId) {
                alert('Ù„Ø·ÙØ§Ù‹ Ù‡Ø± Ø¯Ùˆ ØªÛŒÙ… Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯');
                return;
            }

            if (homeTeamId === awayTeamId) {
                alert('ØªÛŒÙ… Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø§ Ø®ÙˆØ¯Ø´ Ø¨Ø§Ø²ÛŒ Ú©Ù†Ø¯');
                return;
            }

            const homeTeam = teams.find(t => t.id === homeTeamId);
            const awayTeam = teams.find(t => t.id === awayTeamId);

            // Update ELO ratings for all teams
            updateELORatings();

            // Use Machine Learning Model for prediction
            const prediction = mlModel.predict(homeTeam, awayTeam);
            
            // Calculate predicted score using Poisson distribution
            const predictedScore = calculatePredictedScore(homeTeam, awayTeam);

            displayPrediction(homeTeam, awayTeam, {
                ...prediction,
                predictedScore: predictedScore,
                modelType: 'Machine Learning + Neural Network',
                eloRatings: {
                    home: Math.round(homeTeam.eloRating),
                    away: Math.round(awayTeam.eloRating)
                },
                aiScores: {
                    home: Math.round(homeTeam.aiScore || 1500),
                    away: Math.round(awayTeam.aiScore || 1500)
                }
            });
        }

        function calculatePredictedScore(homeTeam, awayTeam) {
            const homeAttack = calculateAttackStrength(homeTeam, true);
            const awayDefense = calculateDefenseStrength(awayTeam, false);
            const awayAttack = calculateAttackStrength(awayTeam, false);
            const homeDefense = calculateDefenseStrength(homeTeam, true);

            const homeExpectedGoals = homeAttack * awayDefense;
            const awayExpectedGoals = awayAttack * homeDefense;

            return `${Math.round(homeExpectedGoals)} - ${Math.round(awayExpectedGoals)}`;
        }

        // ELO Rating System
        function updateELORatings() {
            // Initialize ELO ratings if not exists
            teams.forEach(team => {
                if (!team.eloRating) {
                    team.eloRating = 1500; // Standard starting ELO
                }
            });

            // Update ELO based on match results
            matches.forEach(match => {
                const homeTeam = teams.find(t => t.id === match.homeTeam);
                const awayTeam = teams.find(t => t.id === match.awayTeam);
                
                if (homeTeam && awayTeam && !match.eloProcessed) {
                    updateELOForMatch(homeTeam, awayTeam, match.homeGoals, match.awayGoals);
                    match.eloProcessed = true;
                }
            });
        }

        function updateELOForMatch(homeTeam, awayTeam, homeGoals, awayGoals) {
            const K = 32; // ELO K-factor
            const homeAdvantage = 100; // Home advantage in ELO points

            // Expected scores
            const expectedHome = 1 / (1 + Math.pow(10, (awayTeam.eloRating - homeTeam.eloRating - homeAdvantage) / 400));
            const expectedAway = 1 - expectedHome;

            // Actual scores
            let actualHome, actualAway;
            if (homeGoals > awayGoals) {
                actualHome = 1; actualAway = 0;
            } else if (homeGoals < awayGoals) {
                actualHome = 0; actualAway = 1;
            } else {
                actualHome = 0.5; actualAway = 0.5;
            }

            // Update ratings
            homeTeam.eloRating += K * (actualHome - expectedHome);
            awayTeam.eloRating += K * (actualAway - expectedAway);
        }

        // Helper functions for attack/defense calculations
        function calculateAttackStrength(team, isHome) {
            const totalGames = team.wins + team.draws + team.losses;
            if (totalGames === 0) return 1.2;

            let baseAttack = team.goalsFor / totalGames;
            
            // ELO adjustment
            const eloFactor = (team.eloRating - 1500) / 400;
            baseAttack *= (1 + eloFactor * 0.3);

            // Home advantage
            if (isHome) baseAttack *= 1.15;

            // Recent form adjustment
            const recentForm = mlModel.getRecentForm(team, 5);
            baseAttack *= (0.8 + recentForm * 0.4);

            return Math.max(0.3, Math.min(4.0, baseAttack));
        }

        function calculateDefenseStrength(team, isHome) {
            const totalGames = team.wins + team.draws + team.losses;
            if (totalGames === 0) return 1.2;

            let baseDefense = team.goalsAgainst / totalGames;
            
            // ELO adjustment (inverse for defense)
            const eloFactor = (1500 - team.eloRating) / 400;
            baseDefense *= (1 + eloFactor * 0.3);

            // Home advantage (better defense at home)
            if (isHome) baseDefense *= 0.9;

            // Recent form adjustment (inverse for defense)
            const recentForm = mlModel.getRecentForm(team, 5);
            baseDefense *= (1.2 - recentForm * 0.4);

            return Math.max(0.3, Math.min(4.0, baseDefense));
        }

        function displayPrediction(homeTeam, awayTeam, prediction) {
            const resultDiv = document.getElementById('prediction-result');
            
            let mostLikely = 'Ù…Ø³Ø§ÙˆÛŒ';
            let maxProb = prediction.drawProb;
            
            if (prediction.homeWinProb > maxProb) {
                mostLikely = `Ø¨Ø±Ø¯ ${homeTeam.name}`;
                maxProb = prediction.homeWinProb;
            }
            if (prediction.awayWinProb > maxProb) {
                mostLikely = `Ø¨Ø±Ø¯ ${awayTeam.name}`;
                maxProb = prediction.awayWinProb;
            }

            resultDiv.innerHTML = `
                <h4 class="text-2xl font-bold mb-4">ğŸ¤– Ù¾ÛŒØ´Ø¨ÛŒÙ†ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h4>
                <div class="text-3xl font-bold mb-4">${homeTeam.name} vs ${awayTeam.name}</div>
                <div class="text-4xl font-bold mb-6">âš½ ${prediction.predictedScore}</div>
                
                <div class="grid grid-cols-3 gap-4 mb-6">
                    <div class="bg-white bg-opacity-20 rounded-lg p-4">
                        <div class="text-sm opacity-80">Ø¨Ø±Ø¯ ${homeTeam.name}</div>
                        <div class="text-2xl font-bold">${Math.round(prediction.homeWinProb)}%</div>
                    </div>
                    <div class="bg-white bg-opacity-20 rounded-lg p-4">
                        <div class="text-sm opacity-80">Ù…Ø³Ø§ÙˆÛŒ</div>
                        <div class="text-2xl font-bold">${Math.round(prediction.drawProb)}%</div>
                    </div>
                    <div class="bg-white bg-opacity-20 rounded-lg p-4">
                        <div class="text-sm opacity-80">Ø¨Ø±Ø¯ ${awayTeam.name}</div>
                        <div class="text-2xl font-bold">${Math.round(prediction.awayWinProb)}%</div>
                    </div>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-6">
                    <div class="bg-white bg-opacity-15 rounded-lg p-3">
                        <div class="text-sm opacity-80">Ø§Ù…ØªÛŒØ§Ø² ELO</div>
                        <div class="text-lg font-bold">${prediction.eloRatings.home} - ${prediction.eloRatings.away}</div>
                    </div>
                    <div class="bg-white bg-opacity-15 rounded-lg p-3">
                        <div class="text-sm opacity-80">Ø§Ù…ØªÛŒØ§Ø² AI</div>
                        <div class="text-lg font-bold">${prediction.aiScores.home} - ${prediction.aiScores.away}</div>
                    </div>
                </div>
                
                <div class="text-lg mb-2">
                    <strong>ğŸ¯ Ø§Ø­ØªÙ…Ø§Ù„ Ø¨ÛŒØ´ØªØ±:</strong> ${mostLikely} (${Math.round(maxProb)}%)
                </div>
                <div class="text-sm opacity-80">
                    ğŸ§  Ø³Ø·Ø­ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†: ${Math.round(prediction.confidence)}% | Ù…Ø¯Ù„: ${prediction.modelType || 'Neural Network + Random Forest'}
                </div>
                ${!modelTrained ? '<div class="text-xs opacity-70 mt-2">ğŸ’¡ Ø¨Ø±Ø§ÛŒ Ø¯Ù‚Øª Ø¨ÛŒØ´ØªØ±ØŒ Ù…Ø¯Ù„ AI Ø±Ø§ Ø¢Ù…ÙˆØ²Ø´ Ø¯Ù‡ÛŒØ¯</div>' : ''}
            `;
            
            resultDiv.classList.remove('hidden');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadData(); // Load saved data on startup
            updateTeamsDisplay();
            updateMatchesDisplay();
            updateTeamSelects();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'97a88c85c022a1ec',t:'MTc1NzEwNDkwMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>